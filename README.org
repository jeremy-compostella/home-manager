#+OPTIONS: broken-links:t toc:nil hidestars indent inlineimages author:nil ^:nil
#+AUTHOR: Jeremy Compostella <jeremy.compostella@gmail.com>
#+EXPORT_FILE_NAME: README.md

*Solar Power usage optimization in a residential home*

#+name: monthly-data
#+begin_src python :session :exports none :results output
  from dateutil import parser
  from src.tools import get_database

  def dict_factory(cursor, row):
      data = {}
      for idx, col in enumerate(cursor.description):
          data[col[0]] = row[idx]
      return data

  def total(record):
      return sum([v for k, v in record.items() \
                  if k not in ['net', 'solar', 'from_grid',
                               'to_grid', 'title', 'local']])

  def monthly_data():
      months = {}
      with get_database() as database:
          database.row_factory = dict_factory
          cursor = database.cursor()
          req = 'SELECT * FROM daily_power'
          cursor.execute(req)
          daily_power = cursor.fetchall()
      for day in daily_power:
          month = parser.parse(day['timestamp']).strftime("%B\n%Y")
          if month in months:
              months[month] = {k:months[month][k] + v \
                               for k, v in day.items() \
                               if k != 'timestamp'}
          else:
              months[month] = day.copy()
      for month in months:
          record = months[month]
          record['other'] = -(total(record) + record['solar'] - record['net'])
          for key, value in record.items():
              record[key] = abs(value)
          record['hvac'] = record['a_c'] + record['air_handler']
          record['local'] = record['solar'] - record['to_grid']
          del record['a_c']
          del record['air_handler']
          record['title'] = '%s' % month
      return list(months.values())

  print(monthly_data())
#+end_src

#+name: ev+hvac+water-heater
#+begin_src python :session :exports none :results value :var data=monthly-data
  data = eval(data)
  total = sum([record['local'] + record['from_grid'] for record in data])
  devices = sum(sum(record[d] for d in ['ev', 'hvac', 'water_heater']) \
		for record in data)
  '%.1f%%' % (100 * devices / total)
#+end_src

This project aims to optimize the use of solar produced energy in a residential home. In the implementation described below it optimizes three appliances: an Electric Vehicle charger, a water heater and an HVAC system. The project has focused so far on these three appliances because they add up to approximately call_ev+hvac+water-heater() {{{results(=72.5%=)}}} of a my home energy usage and they are a form of energy storage.

My home is located in Phoenix, Arizona and my solar system is not equipped with battery system. Even though at this location 296 days per year are either sunny or partly sunny, photovoltaic production is still highly unpredictable.

There are a couple of ways to measure the performance of a solar panels system in a residential home depending on expectations.
1. Return On Investment (ROI): measure from a financial point of point when does the system paid for itself and how much value it can create in it life time.
2. Usage vs. production ratio at the time of need: measure the "waste" of the production. This metric can be used to design systems with the best ROI. In Phoenix, Arizona utility companies buy the over production from residential home for a small fraction of the price of the energy they sell. Minimizing the over-production is critical to generate the best ROI.
3. Solar produced energy usage performance as measured by the ratio of energy used from the solar panel over the total energy used. To me this is the most environment oriented metric and this is the one I track.

With a few experiments, I quickly confirmed the obvious: a time based schedule is not going to be enough to meet to the ambitious goal of running 100% of the car and \approx 60 to 70% of my entire home consumption coming from the solar panels production.

The illustration below shows the distribution of the energy consumption of my home since I started this project.

#+begin_src python :session: :results file :exports results :var data=monthly-data
   import matplotlib.pyplot as plt
   import numpy as np

   data = eval(data)
   width = 0.35
   fig, ax = plt.subplots()
   fig.set_size_inches(11.75, 5.79)

   x = np.arange(len(data))
   ax.bar(x - width/2,
	    [record['local'] for record in data],
	    width, bottom=[record['from_grid'] for record in data],
	    label='Energy from the solar production', color='lightblue')
   ax.bar(x - width/2, [record['from_grid'] for record in data],
	    width, label='Energy from the grid', color='lightcoral')

   for i, record in enumerate(data):
       ax.text(i - width/2 - .1, record['from_grid'] + record['local'] + 20,
		 '%d%%' % (record['local'] / (record['local'] + record['from_grid']) * 100),
		 color='lightblue', fontweight='bold')

   prev = [0.0 for _ in data]
   COLORS = {'pool':"tab:blue",
	       'water_heater': 'gold',
	       'hvac': 'tab:cyan',
	       'range': 'tab:red',
	       'ev': 'tab:green',
	       'dryer': 'tab:orange',
	       'other': 'lightgrey'}
   for consumer in ['pool', 'water_heater', 'hvac', 'range',
		      'ev', 'dryer', 'other']:
       ax.bar(x + width/2 + .01,
		 [record[consumer] for record in data],
		 width, bottom=prev, label=consumer, color=COLORS[consumer])
       prev = [a + b for a, b in zip([record[consumer] for record in data], prev)]

   ax.set_xticks(x)
   ax.set_xticklabels([record['title'] for record in data])
   ax.set_title('Energy consumption distribution')
   ax.legend(loc='best')
   plt.grid(which='major', linestyle='dotted')
   fname = 'doc/images/energy_consumption_distribution.png'
   fig.tight_layout()
   plt.savefig(fname)
   return fname
#+end_src

#+RESULTS:
[[file:doc/images/energy_consumption_distribution.png]]

#+name: powered-by-solar
#+begin_src python :session :exports none :results value :var data=monthly-data
  data = eval(data)
  '%.1f%%' % ((1 - (sum([record['from_grid'] for record in data]) /
       sum([total(record) for record in data]))) * 100)
#+end_src

#+name: db-first-month
#+begin_src python :session :exports none :results value :var data=monthly-data
  data = eval(data)
  data[0]['title'].replace('\n', ' ')
#+end_src

#+name: db-last-month
#+begin_src python :session :exports none :results value :var data=monthly-data
  data = eval(data)
  data[-1]['title'].replace('\n', ' ')
#+end_src

I started the project during summer and made considerable progress since then but we also have to factor in that during summer the HVAC has to run at night and is necessarily going to have a significant impact on this metric. Nevertheless, it allows to see that between call_db-first-month() {{{results(=June 2021=)}}} and call_db-last-month() {{{results(=January 2022=)}}}, on average \approx call_powered-by-solar() {{{results(=62.0%=)}}} of the electricity used by my home came from the solar panels.

The implementation relies on various modules providing services such as weather forecast, instant power consumption records, solar power prediction, home thermal model, appliances controls and a scheduler. *Note*: This project implementation is not generic enough to be plugged-in as-is to control any system. Some modules rely on specific hardware devices or specific software interfaces. For instance, the ~car_charger~ task module relies on the Pulsar II Wallbox\reg charger   and have dependencies on their cloud service. Nevertheless, I believe that most of this project can be re-use in various forms and this is why I made it available publicly.

When I started this project I discarded existent Home Automation "framework" such as Home Assistant as I didn't want my design to be tighten to a framework or have to carry the burden of software architecture which could have made my work more difficult. Also, I originally needed a prompt solution to charge my car smartly and I did not have time to dig in the various frameworks. However, this project is modular enough that I have been able to quickly integrate it to Home Assistant as you can see in the screen capture below.

[[./doc/images/scheduler_at_work.png]]

The software architecture is based on well separated python modules each running in their dedicate process. Each module implements known interfaces such as [[doc/sensor.md#sensor-objects][Sensor]] or [[doc/scheduler.md#task-objects][Task]]. Alternatively or in addition, a module can expose its a original service interface. The inter-processes communication is guaranteed by the [[https://pypi.org/project/Pyro5/][pyro5]] remote objects communication library. Each service, sensor or task is registered to a pyro5 nameserver under the ~home-manager~ namespace.  The services are under the ~home-manager.service~ sub-namespace, the sensors under the ~home-manager.sensor~ sub-namespace and the tasks are under the ~home-manager.task~ sub-namespace. For instance, the task responsible of the HVAC system is implemented by the [[./src/hvac.py][hvac.py]] program and registered as ~home-manager.task.hvac~ to the nameserver.

The diagram below represents the principal communications between the main modules.

#+begin_src dot :file doc/images/programs-communication.png :exports results
  digraph {
          node [shape=box];
          "car_charger" -> "scheduler"
          "car_charger" -> "power_sensor"
          "car_charger" -> "power_simulator"
          "car_charger" -> "car_sensor"

          "hvac" -> "scheduler"
          "hvac" -> "power_simulator"
          "hvac" -> "weather"

          "power_simulator" -> "power_sensor"
          "power_simulator" -> "weather"

          "scheduler" -> "power_sensor"
          "scheduler" -> "power_simulator"

          "water_heater" -> "scheduler"
  }
#+end_src

#+RESULTS:
[[file:doc/images/programs-communication.png]]

Now let's have go a short presentation or the modules:

_The main sensors are_:
1. The [[./doc/power_sensor.md][power_sensor]] (~home_manager.sensor.power~) module provides instantaneous power consumption and power production readings. It also provides power reading over a certain period of time such as one minute, one hour or one day. This sensor is used by the [[./doc/scheduler.md][scheduler]] to build power consumption statistics leading to task scheduling decisions. Some task such as [[./doc/car_charger.md][car_charger]] also uses this sensor.
2. The [[./doc/power_simulator.md][power_simulator]] (~home_manager.sensor.power_simulator~ and ~home_manager.sensor.power_simulator~) module implements the solar panel model of my installation using the python [[https://pvlib-python.readthedocs.io/en/stable/][pvlib]] library.
   - Similarly to [[./doc/power_sensor.md][power_sensor]] the sensor part of this module provides instantaneous power consumption and production readings except that the production reading are based on a solar panel model and the consumption reading are based on current the tasks status. This [[./doc/power_simulator.md][power_simulator]] is used as an alternative if [[./doc/power_sensor.md][power_sensor]] is failing by the [[./doc/scheduler.md][scheduler]] and the [[./doc/car_charger.md][car_charger]].
   - The service part of this module provides properties and functions such as:
     - the [[./doc/power_simulator.md#max_available_power][max_available_power]] property which is the maximum instantaneous power in kW the solar panels are expected to deliver from now to the end of daytime
     - the [[./doc/power_simulator.md#next_power_window][next_power_window(power)]] function which returns the next time frame when ~power~ kW would be available on a perfectly sunny day. This information is useful to tasks which need to know until when they can expect to get enough power to run.
3. The [[./doc/weather.md][weather]] (~home_manager.sensor.weather~ and ~home_manager.service.weather~) module provides instantaneous weather information such as temperature or wind speed as a [[doc/sensor.md#sensor-objects][Sensor]] object. It also provides weather forecast service with methods to get data such as the temperature at the certain point in time. The forecast service is important to multiple modules. For instance, a solar panel production performance depends on multiple factors and in particular the temperature thus the [[./doc/power_simulator.md][power_simulator]] uses the weather forecast service to compute an accurate PV panels productions estimation.
4. The [[./doc/car_sensor.md][car_sensor]] (~home_manager.sensor.car~) module provides information such as the car current state of charge and mileage.

The central piece of the system is the [[./doc/scheduler.md][scheduler]]. The [[./doc/scheduler.md][scheduler]] is responsible of optimally schedule registered tasks depending on their priority level, their power needs, some task specific running criteria and of course, power availability. The scheduler module evaluates the situation and makes new decision every minutes. It computes power consumption statistics with a sliding window of power records and uses this data to determine the ratio of the energy a particular appliance has been consuming compared to what the photovoltaic system has been producing. This ratio represents how much of the energy used by a particular appliance has been covered by the photovoltaic production. This ratio is provided to each tasks which are responsible to let the scheduler know if this ratio would be good enough to start the task or keep it running if it is already started.

The project provides multiple tasks:
1. The [[./doc/car_charger.md][car_charger]] task is responsible of charging the Electric Vehicle. It uses a simple strategy: the priority is set depending on the car current state of charge, the lower the state of charge the higher the priority. When this task is started, it automatically adjusts the charging rate depending on the power availability and it does so multiple times a minute.
2. The [[./doc/water_heater.md][water_heater]] task is responsible of heating the water tank. In opposition to the car which has a large enough capacity to be able to skip a couple of days of charge the water heater has to run every single day regardless of the photovoltaic production. Therefor the strategy is a little bit more complex: the task priority is set based on the water tank level and temperature but also on how close we are of the target time. The target time is defined as the last point in time of the day when the photovoltaic system theoretically produces enough power to cover 100% of the water heater needs. In addition to that, if the priority is the highest possible and we are close to the target time, the water heater reports that it meets its running criteria regardless of the current consumption/production ratio. That way the [[./doc/water_heater.md][water_heater]] task is guaranteed to be scheduled and meet its daily goal.
3. The [[./doc/hvac.md][hvac]] task is responsible of heating and cooling the home during daylight. At night, the regular thermostat schedule resumes. In my home the HVAC system clearly is the appliance consuming the most energy and this is why the HVAC optimization is critical.
   Similarly to the [[./doc/water_heater.md][water_heater]] task a target time is determined thanks to the [[./doc/power_simulator.md][power_simulator]]. However, the algorithm determining the target time is slightly more complex because the HVAC system power consumption varies when the outdoor temperature changes and under high temperature or low temperature, the HVAC system needs more power than what the photovoltaic system can produce. In order to calculate the target time, the hvac task uses a performance model of the HVAC system built out of data recorded over several month of use. The following diagram is a representation of the HVAC performance model. For a certain range of outdoor temperatures, the blue line represents the power used by the HVAC system and the orange line the number of minutes needed to change the temperature by one degree Fahrenheit.
   [[./doc/images/hvac_model.png]]
   The HVAC system needs a target time but also a target temperature. The target temperature is defined as the temperature to be at target time so that at a later specified time the home would be at a desired temperature. For instance, if the desire is to have a temperature of 73Â°F at 11pm, the [[./doc/hvac.md][hvac]] task computes what the temperature should be at target time taking into account the expected temperature change of the home between the target time and 11PM. This computation relies on a home thermal model built out of data captured over several months.
