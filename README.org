#+OPTIONS: toc:nil hidestars indent inlineimages
#+OPTIONS: ^:nil
#+AUTHOR: Jeremy Compostella <jeremy.compostella@gmail.com>
#+EXPORT_FILE_NAME: README.md
#+TITLE: Solar Power usage optimization in a residential home

#+name: monthly-data
#+begin_src python :session :exports none :results output
  from dateutil import parser
  from src.tools import get_database

  def dict_factory(cursor, row):
      data = {}
      for idx, col in enumerate(cursor.description):
          data[col[0]] = row[idx]
      return data

  def total(record):
      return sum([v for k, v in record.items() \
                  if k not in ['net', 'solar', 'from_grid',
                               'to_grid', 'title', 'local']])

  def monthly_data():
      months = {}
      with get_database() as database:
          database.row_factory = dict_factory
          cursor = database.cursor()
          req = 'SELECT * FROM daily_energy'
          cursor.execute(req)
          daily_energy = cursor.fetchall()
      for day in daily_energy:
          month = parser.parse(day['timestamp']).strftime("%B\n%Y")
          if month in months:
              months[month] = {k:months[month][k] + v \
                               for k, v in day.items() \
                               if k != 'timestamp'}
          else:
              months[month] = {k:v for k, v in day.items() if k != 'timestamp'}
      for month in months:
          record = months[month]
          record['other'] = -(total(record) + record['solar'] - record['net'])
          for key, value in record.items():
              record[key] = abs(value)
          record['hvac'] = record['a_c'] + record['air_handler']
          record['local'] = record['solar'] - record['to_grid']
          del record['a_c']
          del record['air_handler']
          record['title'] = '%s' % month
      return list(months.values())

  print(monthly_data())
#+end_src

#+RESULTS: monthly-data

#+name: usage-share
#+begin_src python :session :exports none :results value :var data=monthly-data devices="ev,hvac,water_heater"
  data = eval(data)
  total = sum([record['local'] + record['from_grid'] for record in data])
  # devices = sum(sum(record[d] for d in ['ev', 'hvac', 'water_heater']) \
  devices = sum(sum(record[d] for d in devices.split(',')) \
		for record in data)
  '%d%%' % round(100 * devices / total)
#+end_src

This project is about *Solar power usage optimization in a residential home*. It is a set of software components and services scheduling and optimizing devices in the a residential to make the best use of solar generated power.

Back in May 2021, I installed solar panel on my roof. As a software engineer concerned by the global warming I decided to develop an optimization system to reduce my carbon footprint. As I would like this project to benefit other and to keep growing I decided to share it publicly.

Optimizing means a good understanding of what to optimize. I spent some time online and I started collecting data from my electrical panel by installing sensors. I quickly to identified the following four targets (in order of priority):
1. The electric car
2. The HVAC (Heating, Ventilation, and Air Conditioning),
3. The water heater
4. The pool pump

*Note*: As of today, the system covers the first three as I still need to find the right switch to control the pool pump.

#+begin_src python :session: :results file :exports results :var data=monthly-data
  import matplotlib.pyplot as plt

  # Pie chart, where the slices will be ordered and plotted counter-clockwise:
  data = eval(data)
  total = sum([record['local'] + record['from_grid'] for record in data])
  dev_labels = {'hvac': 'HVAC',
		'ev': 'Electric Car',
		'water_heater': 'Water Heater',
		'pool': 'Pool Pump',
		'range': 'Kitchen Range',
		'other': 'Other'}
  sizes = [sum(100 * record[key] / total for record in data) \
	   for key in dev_labels]
  explode = (0, 0, 0, 0, 0, 0)
  fig1, ax1 = plt.subplots()
  ax1.pie(sizes, explode=explode, labels=dev_labels.values(),
	  autopct='%.0f%%', shadow=True, startangle=90)
  ax1.axis('equal')

  fname = 'doc/images/yearly_energy_consumption_distribution.svg'
  plt.tight_layout()
  figure = plt.gcf()
  figure.set_size_inches(10, 4.93)
  plt.savefig(fname)
  return fname
#+end_src

#+RESULTS:
[[file:doc/images/yearly_energy_consumption_distribution.svg]]

An optimization system also requires performance metrics.  My motivation being environmental and knowing that the utility companies of my city are mostly producing electricity out of fossil energies, I decided to measure the performance as the ratio of energy used from the solar panel over the total energy used. It means that the goal of the system is to fit as much as possible the home electricity needs in the time frame the solar panels are producing.

I have set up two targets:
1. The electric car should be charged at 100% with solar produced energy
2. The home energy consumption (including the car charger) must be covered at more than 65% by the solar energy

As of today, between call_db-first-month() {{{results(=June 2021=)}}} and call_db-last-month() {{{results(=February 2022=)}}}, the entire home energy consumption has been covered by solar energy at call_powered-by-solar() {{{results(=63%=)}}}.

The following diagram represents the distribution of the energy consumption of my home per month since I started this project. It also include the per-month ratio of energy used which originated from the solar panels.

#+begin_src python :session: :results file :exports results :var data=monthly-data
  import matplotlib.pyplot as plt
  import numpy as np

  LABELS = {'pool': 'Pool',
	    'water_heater': 'Water heater',
	    'hvac': 'HVAC',
	    'range': 'Kitchen range',
	    'ev': 'Electric Vehicle',
	    'dryer': 'Dryer',
	    'other': 'Other'}

  data = eval(data)
  width = 0.35
  fig, ax = plt.subplots()
  fig.set_size_inches(11.75, 5.79)

  x = np.arange(len(data))
  ax.bar(x - width/2,
	 [record['local'] for record in data],
	 width, bottom=[record['from_grid'] for record in data],
	 label='Energy from the solar production', color='lightblue')
  ax.bar(x - width/2, [record['from_grid'] for record in data],
	 width, label='Energy from the grid', color='lightcoral')

  for i, record in enumerate(data):
      ax.text(i - width/2 - .1, record['from_grid'] + record['local'] + 20,
	      '%d%%' % round(record['local'] / (record['local'] + record['from_grid']) * 100),
	      color='lightblue', fontweight='bold')

  prev = [0.0 for _ in data]
  COLORS = {'pool':"tab:blue",
	    'water_heater': 'gold',
	    'hvac': 'tab:cyan',
	    'range': 'tab:red',
	    'ev': 'tab:green',
	    'dryer': 'tab:orange',
	    'other': 'lightgrey'}
  for consumer in ['pool', 'water_heater', 'hvac', 'range',
		   'ev', 'dryer', 'other']:
      ax.bar(x + width/2 + .01,
	     [record[consumer] for record in data],
	     width, bottom=prev, label=LABELS[consumer],
	     color=COLORS[consumer])
      prev = [a + b for a, b in zip([record[consumer] for record in data], prev)]

  ax.set(ylabel='kWh')
  ax.set_xticks(x)
  ax.set_xticklabels([record['title'] for record in data])
  ax.set_title('Energy Consumption Distribution')
  ax.set_yticks(np.arange(0, 2100, step=100))
  ax.legend(loc='best')
  plt.grid(which='major', linestyle='dotted')
  fname = 'doc/images/energy_consumption_distribution.svg'
  fig.tight_layout()
  plt.savefig(fname)
  return fname
#+end_src

#+RESULTS:
[[file:doc/images/energy_consumption_distribution.svg]]

#+name: powered-by-solar
#+begin_src python :session :exports none :results value :var data=monthly-data
  data = eval(data)
  '%d%%' % round((1 - (sum([record['from_grid'] for record in data]) /
       sum([total(record) for record in data]))) * 100)
#+end_src

#+name: db-first-month
#+begin_src python :session :exports none :results value :var data=monthly-data
  data = eval(data)
  data[0]['title'].replace('\n', ' ')
#+end_src

#+name: db-last-month
#+begin_src python :session :exports none :results value :var data=monthly-data
  data = eval(data)
  data[-1]['title'].replace('\n', ' ')
#+end_src

The implementation relies on various modules providing services such as weather forecast, instant power consumption records, solar power prediction, home thermal model, appliances controls and a scheduler. In a modest way, this is learning system. Indeed, it collects data and uses this data to generate models which influence the system decisions.

This project also includes some basic Home Assistant integration to ease the monitoring and control of the system as seen in the following screen capture.

[[./doc/images/scheduler_at_work.png]]

The software architecture is based on well separated python modules running in dedicated processes. Each module implements defined interfaces such as [[file:doc/sensor.md#sensor-objects][Sensor]] or [[file:doc/scheduler.md#task-objects][Task]]. Alternatively or in addition, a module can expose its a original Service interface. The inter-processes communication is provided by the [[https://pypi.org/project/Pyro5/][pyro5]] remote objects communication library. Each service, sensor or task is registered to the pyro5 nameserver under the ~home-manager~ namespace.  The services are under the ~home-manager.service~ sub-namespace, the sensors under the ~home-manager.sensor~ sub-namespace and the tasks are under the ~home-manager.task~ sub-namespace. For instance, the task responsible of the HVAC system is implemented by the [[./src/hvac.py][hvac]] module and registered as ~home-manager.task.hvac~ to the nameserver.

The following diagram represents the most important dependencies between the principal modules.

#+begin_src dot :file doc/images/programs-communication.svg :exports results
  digraph {
          node [shape=box];
          "car_charger" -> "scheduler"
          "car_charger" -> "power_sensor"
          "car_charger" -> "power_simulator"
          "car_charger" -> "car_sensor"

          "hvac" -> "scheduler"
          "hvac" -> "power_simulator"
          "hvac" -> "weather"

          "power_simulator" -> "power_sensor"
          "power_simulator" -> "weather"

          "scheduler" -> "power_sensor"
          "scheduler" -> "power_simulator"

          "water_heater" -> "scheduler"
  }
#+end_src

#+RESULTS:
[[file:doc/images/programs-communication.svg]]

_The main sensors are_:
1. The [[./doc/power_sensor.md][power_sensor]] (~home_manager.sensor.power~) module provides instantaneous power consumption and power production readings. It also provides power reading over a certain period of time such as one minute, one hour or one day. This sensor is used by the [[./doc/scheduler.md][scheduler]] to build power consumption statistics leading to task scheduling decisions. Some task such as the [[./doc/car_charger.md][car_charger]] also uses this sensor.
2. The [[./doc/power_simulator.md][power_simulator]] (~home_manager.sensor.power_simulator~ and ~home_manager.sensor.power_simulator~) module implements the solar panel model of my installation using the python [[https://pvlib-python.readthedocs.io/en/stable/][pvlib]] library.
   - Similarly to [[./doc/power_sensor.md][power_sensor]] the sensor part of this module provides instantaneous power consumption and production readings except that the production reading are based on a solar panel model and the consumption reading are based on current the tasks status. This [[./doc/power_simulator.md][power_simulator]] is used as an alternative if [[./doc/power_sensor.md][power_sensor]] is failing by the [[./doc/scheduler.md][scheduler]] and the [[./doc/car_charger.md][car_charger]].
   - The service part of this module provides properties and functions such as:
     - the [[./doc/power_simulator.md#max_available_power][max_available_power]] property which is the maximum instantaneous power in kW the solar panels are expected to deliver from now to the end of daytime
     - the [[./doc/power_simulator.md#next_power_window][next_power_window(power)]] function which returns the next time frame when ~power~ kW would be available on a perfectly sunny day. This information is useful to tasks which need to know until when they can expect to get enough power to run.
3. The [[./doc/weather.md][weather]] (~home_manager.sensor.weather~ and ~home_manager.service.weather~) module provides instantaneous weather information such as temperature or wind speed as a [[file:doc/sensor.md#sensor-objects][Sensor]] object. It also provides weather forecast service with methods to get data such as the temperature at the certain point in time. The forecast service is important to multiple modules. For instance, a solar panel production performance depends on multiple factors and in particular the temperature thus the [[./doc/power_simulator.md][power_simulator]] uses the weather forecast service to compute an accurate PV panels productions estimation.
4. The [[./doc/car_sensor.md][car_sensor]] (~home_manager.sensor.car~) module provides information such as the car current state of charge and mileage.

The central piece of the system is the [[./doc/scheduler.md][scheduler]]. The [[./doc/scheduler.md][scheduler]] is responsible of optimally schedule registered tasks depending on their priority level, their power needs, some task specific running criteria and of course, power availability. The scheduler module evaluates the situation and makes new decision every minutes. It computes power consumption statistics with a sliding window of power records and uses this data to determine the ratio of the energy a particular appliance has been consuming compared to what the photovoltaic system has been producing. This ratio represents how much of the energy used by a particular appliance has been covered by the photovoltaic production. This ratio is provided to each tasks which are responsible to let the scheduler know if this ratio would be good enough to start the task or keep it running if it is already started.

The project provides multiple tasks:
1. The [[./doc/car_charger.md][car_charger]] task is responsible of charging the Electric Vehicle. It uses a simple strategy: the priority is set depending on the car current state of charge, the lower the state of charge the higher the priority. When this task is started, it automatically adjusts the charging rate depending on the power availability and it does so multiple times a minute.
2. The [[./doc/water_heater.md][water_heater]] task is responsible of heating the water tank. In opposition to the car which has a large enough capacity to be able to skip a couple of days of charge the water heater has to run every single day regardless of the photovoltaic production. Therefor the strategy is a little bit more complex: the task priority is set based on the water tank level and temperature but also on how close we are of the target time. The target time is defined as the last point in time of the day when the photovoltaic system theoretically produces enough power to cover 100% of the water heater needs. In addition to that, if the priority is the highest possible and we are close to the target time, the water heater reports that it meets its running criteria regardless of the current consumption/production ratio. That way the [[./doc/water_heater.md][water_heater]] task is guaranteed to be scheduled and meet its daily goal.
3. The [[./doc/hvac.md][hvac]] task is responsible of heating and cooling the home during daylight. At night, the regular thermostat schedule resumes. In my home the HVAC system clearly is the appliance consuming the most energy and this is why the HVAC optimization is critical.
Similarly to the [[./doc/water_heater.md][water_heater]] task a target time is determined thanks to the [[./doc/power_simulator.md][power_simulator]]. However, the algorithm determining the target time is slightly more complex because the HVAC system power consumption varies when the outdoor temperature changes and under high temperature or low temperature, the HVAC system needs more power than what the photovoltaic system can produce. In order to calculate the target time, the hvac task uses a performance model of the HVAC system automatically of the recorded data. The following diagram is a representation of the HVAC performance model. For a certain range of outdoor temperatures, the blue line represents the power used by the HVAC system and the orange line the number of minutes needed to change the temperature by one degree Fahrenheit.
   #+ATTR_MD: :style margin-left: auto; margin-right: auto;
   #+begin_src python :session: :results file :exports results :dir ./src
     import matplotlib.pyplot as plt
     from models import HVACModel

     HVACModel().plot()

     plt.grid(visible=True, which='both', axis='both', linestyle='dotted')
     fname = '../doc/images/hvac_model.svg'
     plt.tight_layout()
     figure = plt.gcf()
     figure.set_size_inches(10, 4.93)
     plt.savefig(fname)
     return fname
   #+end_src

   #+RESULTS:
   [[file:doc/images/hvac_model.svg]]

    One the hvac module has determined a target time it has to decide of a target temperature. The target temperature is defined as the temperature to be at target time so that at a later specified time the home would be at a desired temperature. For instance, if the desire is to have a temperature of 73Â°F at 10:30pm, the [[./doc/hvac.md][hvac]] task computes what the temperature should be at target time taking into account the expected temperature change of the home between the target time and 10:30pm. This computation relies on a two dimensional home thermal model which is computed by processing the data captured on daily basis. The following figure is a representation of the thermal model of my home.

   #+begin_src python :session: :results file :exports results :dir ./src :eval no-export
     import matplotlib.pyplot as plt
     from models import HomeModel

     HomeModel().plot()

     fname = '../doc/images/home_model.png'
     plt.tight_layout()
     figure = plt.gcf()
     figure.set_size_inches(10, 4.93)
     plt.savefig(fname)
     return fname
   #+end_src

   #+RESULTS:
   [[file:doc/images/home_model.png]]
